NODE cummulative_rows
DESCRIPTION >
    Filter data and calculate the running sum of rows in the result set to determine the time range.

SQL >

    %
    SELECT end_ts, start_ts, countMerge(n_rows) OVER (ORDER BY start_ts DESC) AS n_rows
    FROM mv_ts_range
    WHERE
        account_id = {{ String(account_param, '3d823057-c324-448d-bce9-47e120c11928') }}
        AND start_ts
        >= {{ DateTime(start, '2024-03-08 00:00:00') }} - INTERVAL {{ UInt8(days_param, 30) }} DAY
        AND end_ts <= {{ DateTime(start, '2024-03-08 00:00:00') }}
    ORDER BY end_ts DESC



NODE ts_range
DESCRIPTION >
    What is the time period, starting at X, and up to Y, that I need to query in order to get Z amount of rows that I need.

SQL >

    %
    SELECT max(end_ts) AS max_end_ts, min(start_ts) AS min_start_ts
    FROM cummulative_rows
    WHERE
        n_rows > {{ Int32(page, 0) * Int32(page_size, 40) }}
        AND n_rows <= {{ (Int32(page, 0) + 1) * Int32(page_size, 40) }}



NODE logs_result
DESCRIPTION >
    Rreturn the logs within the time range.
    NOTE: this does not guarantee that you get the exact page size. To avoid repeating records, you need to add extra conditions to check the last value on the previous page.

SQL >

    %
    WITH
        (SELECT min_start_ts FROM ts_range) AS start_range,
        (SELECT max_end_ts FROM ts_range) AS end_range

    SELECT created_at, id, payload
    FROM logs
    WHERE
        account_id IN (
            SELECT id
            FROM accounts
            WHERE id = {{ String(account_param, '3d823057-c324-448d-bce9-47e120c11928') }}
        )
        AND created_at >= start_range
        AND created_at <= end_range
        {% if defined(search_param) %}
            AND payload ILIKE concat('%', {{ String(search_param) }}, '%')
        {% end %}
    ORDER BY created_at DESC


